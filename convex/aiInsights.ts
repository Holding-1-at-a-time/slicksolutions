import { mutation, query } from "./_generated/server"
import { v } from "convex/values"

// Create a new AI insight
export const create = mutation({
  args: {
    businessId: v.id("businesses"),
    type: v.string(),
    content: v.string(),
    metadata: v.optional(v.object({})),
  },
  handler: async (ctx, args) => {
    // Verify user has access to this business
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) {
      throw new Error("Unauthorized")
    }

    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("clerkId"), identity.subject))
      .first()

    if (!user || (user.businessId !== args.businessId && user.role !== "admin")) {
      throw new Error("Unauthorized access to business")
    }

    // Create the insight
    const insightId = await ctx.db.insert("aiInsights", {
      businessId: args.businessId,
      type: args.type,
      content: args.content,
      metadata: args.metadata || {},
      createdAt: Date.now(),
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // Expires in 30 days
    })

    return insightId
  },
})

// Get a specific insight by ID
export const get = query({
  args: {
    id: v.id("aiInsights"),
  },
  handler: async (ctx, args) => {
    // Verify user has access to this insight
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) {
      throw new Error("Unauthorized")
    }

    const insight = await ctx.db.get(args.id)
    if (!insight) {
      return null
    }

    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("clerkId"), identity.subject))
      .first()

    if (!user || (user.businessId !== insight.businessId && user.role !== "admin")) {
      throw new Error("Unauthorized access to insight")
    }

    return insight
  },
})

// List insights for a business
export const listByBusiness = query({
  args: {
    businessId: v.id("businesses"),
    type: v.optional(v.string()),
    limit: v.optional(v.number()),
    offset: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    // Verify user has access to this business
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) {
      throw new Error("Unauthorized")
    }

    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("clerkId"), identity.subject))
      .first()

    if (!user || (user.businessId !== args.businessId && user.role !== "admin")) {
      throw new Error("Unauthorized access to business")
    }

    // Build the query
    let insightsQuery = ctx.db.query("aiInsights").filter((q) => q.eq(q.field("businessId"), args.businessId))

    // Add type filter if provided
    if (args.type) {
      insightsQuery = insightsQuery.filter((q) => q.eq(q.field("type"), args.type))
    }

    // Sort by creation date (newest first)
    insightsQuery = insightsQuery.order("desc")

    // Apply pagination
    const limit = args.limit || 10
    const offset = args.offset || 0

    // Execute the query
    return await insightsQuery
      .take(limit + offset)
      .collect()
      .then((insights) => insights.slice(offset, offset + limit))
  },
})

// Delete an insight
export const remove = mutation({
  args: {
    id: v.id("aiInsights"),
  },
  handler: async (ctx, args) => {
    // Verify user has access to this insight
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) {
      throw new Error("Unauthorized")
    }

    const insight = await ctx.db.get(args.id)
    if (!insight) {
      throw new Error("Insight not found")
    }

    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("clerkId"), identity.subject))
      .first()

    if (!user || (user.businessId !== insight.businessId && user.role !== "admin")) {
      throw new Error("Unauthorized access to insight")
    }

    await ctx.db.delete(args.id)
    return args.id
  },
})

// Generate a new insight (this would typically be called from a scheduled task)
export const generateInsight = mutation({
  args: {
    businessId: v.id("businesses"),
    type: v.string(),
  },
  handler: async (ctx, args) => {
    // This would typically call an external AI service or the Next.js API route
    // For now, we'll just create a placeholder insight

    // In a real implementation, this would be replaced with a call to the AI service
    const placeholderContent = `This is a placeholder insight for business ${args.businessId} of type ${args.type}.
    
In a real implementation, this would be generated by the AI service based on business data.`

    const insightId = await ctx.db.insert("aiInsights", {
      businessId: args.businessId,
      type: args.type,
      content: placeholderContent,
      metadata: {
        generatedBy: "placeholder",
        confidence: 0.8,
      },
      createdAt: Date.now(),
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // Expires in 30 days
    })

    return insightId
  },
})

// Count insights by type for a business
export const countByType = query({
  args: {
    businessId: v.id("businesses"),
  },
  handler: async (ctx, args) => {
    // Verify user has access to this business
    const identity = await ctx.auth.getUserIdentity()
    if (!identity) {
      throw new Error("Unauthorized")
    }

    const user = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("clerkId"), identity.subject))
      .first()

    if (!user || (user.businessId !== args.businessId && user.role !== "admin")) {
      throw new Error("Unauthorized access to business")
    }

    // Get all insights for the business
    const insights = await ctx.db
      .query("aiInsights")
      .filter((q) => q.eq(q.field("businessId"), args.businessId))
      .collect()

    // Count by type
    const counts: Record<string, number> = {}
    for (const insight of insights) {
      if (!counts[insight.type]) {
        counts[insight.type] = 0
      }
      counts[insight.type]++
    }

    return counts
  },
})

